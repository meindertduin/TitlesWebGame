@using TitlesWebGame.WebUi.ViewModels
@using TitlesWebGame.Domain.ViewModels
@using TitlesWebGame.WebUi.Interfaces
@using TitlesWebGame.WebUi.Services
@using TitlesWebGame.Domain.Entities
@implements IDisposable;

<div class="container">
    @if (_chosenThisRound == false)
    {
        <div class="row justify-content-center">
            <div class="round-title">@GameViewModel.NextRoundInfo.RoundStatement</div>
        </div>
        <div>
            <GameRoundTimer @ref="_gameRoundTimer" IntervalMs="100" TimeUnits="@(GameViewModel.NextRoundInfo.RoundTimeMs / 100)"/>
        </div>
        @if (GameViewModel.NextRoundInfo is MultipleChoiceRoundInfoViewModel multipleChoiceRoundInfoViewModel)
        {
            <div class="options-container">
    
                @for (int i = 0; i < multipleChoiceRoundInfoViewModel.Choices.Length; i++)
                {
                    var optionNumber = i.ToString();
                    string optionColor = "option-color-" + i;
                    string marks = "ABCDEFGIJKLMNOP";
    
                    <div @onclick="@(e => HandlePlayerChoice(e, optionNumber))" class="option-button @optionColor">
                        <div class="font-weight-bold mr-3">
                            @marks[i] )  
                        </div>
                        <div class="font-weight-bold">
                            @multipleChoiceRoundInfoViewModel.Choices[i]
                        </div>
                    </div>
                }
            </div>
        }
        else if (GameViewModel.NextRoundInfo is CanvasPaintingRoundInfoViewModel canvasPaintingRoundInfo)
        {
            <CanvasPaintingRound @ref="_gameRoundComponent" />
        }
        else if (GameViewModel.NextRoundInfo is CompetitiveArtistVotingRoundInfoViewModel competitiveArtistVotingRoundAnswer)
        {
            <CompetitiveArtistVotingRound Choices="@competitiveArtistVotingRoundAnswer.Choices" />
        }
    }
    else
    {
        <div class="waiting-round-text">
            Waiting for end of round...
        </div>
    }
</div>


@code {
    [CascadingParameter(Name = "GameViewModel")]
    protected GameViewModel GameViewModel { get; set; }

    [CascadingParameter(Name = "GameSocketConnectionManager")]
    protected GameSocketConnectionManager GameSocketConnectionManager { get; set; }

    GameRoundTimer _gameRoundTimer;
    IGameRoundComponent _gameRoundComponent;

    private bool _chosenThisRound = false;

    protected override void OnAfterRender(bool firstRender)
    {
        if (firstRender)
        {
            _gameRoundTimer.TimerDone += HandleTimerDone;
        }
        
        base.OnAfterRender(firstRender);
    }

    private void HandleTimerDone()
    {
        Task.Run(async () => await _gameRoundComponent.HandleTimerDone());
    }
    
    private async Task HandlePlayerChoice(MouseEventArgs e, string answer)
    {
        await GameSocketConnectionManager.SendAnswer(GameViewModel.RoomKey, new GameRoundAnswer()
        {
            Answer = answer,
            ConnectionId = GameViewModel.Player.ConnectionId,
        });
        
        _chosenThisRound = true;
    }

    public void Dispose()
    {
        _gameRoundTimer.TimerDone -= HandleTimerDone;
    }

}